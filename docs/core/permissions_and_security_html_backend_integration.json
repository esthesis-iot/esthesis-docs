{"objectID":"_permissions_and_security.html#backend_integration","parent":"_permissions_and_security.html#backend_integration","pageViews":0,"url":"writerside-documentation/permissions-and-security.html#backend-integration","mainTitle":"Permissions and Security","product":"","headings":"Permissions and Security,Backend integration","content":"You can perform manual security checks using the isPermitted method in the SecurityPermissionsService class (or respectively via the SecurityResource client). There are two variations of this method, one that checks the category and the operation that you want to check, and a similar one that also takes into account a specific resource id. The method returns a boolean value that indicates whether the user has the required permissions or not. For example:\nif (!securityResource.isPermitted(TAG, Operation.DELETE, id)) {\n   throw new QSecurityException(\"You are not allowed to delete this tag.\");\n} else {\n   return super.deleteById(id);\n}\nManually checking for permissions can be helpful in cases where you need to evaluate a more complex logic than just \u0026quot;can user X perform operation Y\u0026quot;, however, for most other cases it is indeed that simple security check the only thing you need to perform. To facilitate scenarios such as this, we have created the ErnPermission annotation. For example:\n@ErnPermission(category \u003d TAG, operation \u003d DELETE)\n@ErnPermission provides two additional features you should be aware of:\n2. bypassForRoles parameter allows you to define a list of roles that are allowed to bypass the permission check. This is useful for cases where you want to allow certain roles to perform an operation regardless of the permissions, for example, system actions. 4. checkResourceId parameter allows you to define whether a specific resource check should be performed or skipped. By default, this is set to true, meaning that the permission check will always try to figure out if you are accessing a specific resource and try to explicitly check permissions for that resource. If you set this to false, the permission check will only check permissions for the category and operation, without taking into account the resource id. The way in which resource id discovery takes place is by inspecting the first argument of the method annotated with @ErnPermission. If the argument is of type String, it will be considered as the resource id; similarly, if the argument is of type BaseEntity, its getId() method will be invoked to get the resource id. In case you have a method that e.g. has a single argument of type String but that argument is not a resource id, you can set the checkResourceId parameter to false and the permission check will not try to extract the resource id from the method argument. ","pageTitle":"Backend integration","metaDescription":"","type":"Documentation","breadcrumbs":"Developers Guide","root":0,"depth":1}